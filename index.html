<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>–ú–µ–≥–∞-–∏–Ω—Ç–µ—Ä—Å–Ω—ã–π —Å–∞–π—Ç | –°–∞–º–∞—è —Å–ª–æ–∂–Ω–∞—è –∫—Ä–∞—Å–æ—Ç–∞</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial Black', 'Segoe UI', sans-serif;
            color: white;
            background-color: black;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 50px;
            border: 1px solid rgba(255, 0, 255, 0.5);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
            color: #fff;
            text-shadow: 0 0 10px cyan, 0 0 20px magenta;
            letter-spacing: 2px;
            pointer-events: none;
        }
        #info h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 200% 200%;
            animation: gradient 3s ease infinite;
        }
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            display: flex;
            gap: 20px;
            background: rgba(20, 20, 30, 0.7);
            backdrop-filter: blur(15px);
            padding: 15px 30px;
            border-radius: 60px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 30px rgba(0,255,255,0.3);
        }
        .mode-btn {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.7);
            font-size: 1.2rem;
            font-weight: bold;
            padding: 12px 24px;
            border-radius: 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 1px solid transparent;
            box-shadow: 0 0 10px transparent;
        }
        .mode-btn:hover {
            border-color: cyan;
            color: white;
            text-shadow: 0 0 10px cyan;
            box-shadow: 0 0 20px cyan;
            transform: scale(1.1);
            background: rgba(0, 255, 255, 0.1);
        }
        .mode-btn.active {
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            color: black;
            font-weight: 900;
            border: 1px solid white;
            box-shadow: 0 0 30px magenta;
        }
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid #00ffff;
            color: #00ffff;
            font-family: monospace;
            font-size: 1.2rem;
            box-shadow: 0 0 20px cyan;
            pointer-events: none;
        }
        #instruction {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 0.9rem;
            background: rgba(0,0,0,0.3);
            padding: 5px 15px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            white-space: nowrap;
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: none;
            z-index: 150;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>‚ö° –ú–ï–ì–ê –ò–ù–¢–ï–†–°–ù–´–ô –°–ê–ô–¢ ‚ö°</h1>
    </div>
    <div id="stats">
        <span id="particle-count">20000</span> —á–∞—Å—Ç–∏—Ü | —Ä–µ–∂–∏–º: <span id="current-mode">–ê–¢–¢–†–ê–ö–¢–û–†</span>
    </div>
    <div id="instruction">üëÜ –¥–≤–∏–≥–∞–π –º—ã—à–∫–æ–π ‚Äî –≤–ª–∏—è–π –Ω–∞ –ø–æ–ª–µ —á–∞—Å—Ç–∏—Ü | –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—è—é—Ç –º–µ—Ö–∞–Ω–∏–∫—É</div>
    <div id="controls">
        <button class="mode-btn active" id="mode-attract">üåå –ê—Ç—Ç—Ä–∞–∫—Ç–æ—Ä</button>
        <button class="mode-btn" id="mode-repel">üí• –†–µ–ø–µ–ª–ª–µ—Ä</button>
        <button class="mode-btn" id="mode-vortex">üåÄ –í–∏—Ö—Ä—å</button>
        <button class="mode-btn" id="mode-random">üé≤ –•–∞–æ—Å</button>
    </div>

    <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º Three.js –∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';

        // --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –°–¶–ï–ù–´ ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.0015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 10, 30);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // --- –≠–õ–ï–ú–ï–ù–¢–´ –£–ü–†–ê–í–õ–ï–ù–ò–Ø ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8;
        controls.enableZoom = true;
        controls.maxDistance = 80;
        controls.minDistance = 15;
        controls.enablePan = false;
        controls.rotateSpeed = 0.5;

        // --- –ü–û–°–¢-–û–ë–†–ê–ë–û–¢–ö–ê (BLOOM + FXAA) ---
        const renderScene = new RenderPass(scene, camera);
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.8;
        bloomPass.radius = 0.8;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // FXAA –¥–ª—è —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
        const effectFXAA = new ShaderPass(FXAAShader);
        effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        composer.addPass(effectFXAA);

        // --- –û–°–í–ï–©–ï–ù–ò–ï ---
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(1, 2, 1);
        scene.add(dirLight);

        const pointLight1 = new THREE.PointLight(0xff00ff, 1, 50);
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x00ffff, 1, 50);
        pointLight2.position.set(-5, -3, 5);
        scene.add(pointLight2);

        // --- –¶–ï–ù–¢–†–ê–õ–¨–ù–´–ï –û–ë–™–ï–ö–¢–´ (–î–õ–Ø –ö–†–ê–°–û–¢–´) ---
        // –°–≤–µ—Ç—è—â–∏–π—Å—è —Ç–æ—Ä
        const torusGeo = new THREE.TorusKnotGeometry(3, 0.8, 128, 16);
        const torusMat = new THREE.MeshStandardMaterial({
            color: 0xaa44ff,
            emissive: 0x4411aa,
            roughness: 0.2,
            metalness: 0.8,
            wireframe: false,
            emissiveIntensity: 1.5
        });
        const torusKnot = new THREE.Mesh(torusGeo, torusMat);
        torusKnot.position.set(0, 0, 0);
        scene.add(torusKnot);

        // –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Å–≤–µ—Ç—è—â–∞—è—Å—è —Å—Ñ–µ—Ä–∞
        const sphereGeo = new THREE.IcosahedronGeometry(1.8, 3);
        const sphereMat = new THREE.MeshStandardMaterial({
            color: 0xffaa00,
            emissive: 0xff2200,
            roughness: 0.1,
            metalness: 0.3,
            emissiveIntensity: 2.0
        });
        const sphere = new THREE.Mesh(sphereGeo, sphereMat);
        sphere.position.set(0, 0, 0);
        scene.add(sphere);

        // –ú–∞–ª–µ–Ω—å–∫–∏–µ –≤—Ä–∞—â–∞—é—â–∏–µ—Å—è –∫—É–±—ã –≤–æ–∫—Ä—É–≥
        const cubes = [];
        for (let i = 0; i < 12; i++) {
            const geo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const mat = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(i / 12, 1, 0.5),
                emissive: new THREE.Color().setHSL(i / 12, 1, 0.2),
                emissiveIntensity: 1.0
            });
            const cube = new THREE.Mesh(geo, mat);
            const angle = (i / 12) * Math.PI * 2;
            cube.position.set(Math.cos(angle)*5, Math.sin(angle*2)*2, Math.sin(angle)*5);
            scene.add(cube);
            cubes.push(cube);
        }

        // --- –ß–ê–°–¢–ò–¶–´ (–û–°–ù–û–í–ù–ê–Ø –ú–ï–•–ê–ù–ò–ö–ê) ---
        const particleCount = 20000;
        const particles = new THREE.BufferGeometry();

        // –ü–æ–∑–∏—Ü–∏–∏
        const positions = new Float32Array(particleCount * 3);
        // –¶–≤–µ—Ç–∞
        const colors = new Float32Array(particleCount * 3);
        // –°–∫–æ—Ä–æ—Å—Ç–∏ (–¥–ª—è —Ñ–∏–∑–∏–∫–∏ –Ω–∞ CPU)
        const velocities = [];

        const color = new THREE.Color();

        for (let i = 0; i < particleCount; i++) {
            // –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≤ —Å—Ñ–µ—Ä–µ —Å –±–æ–ª—å—à–µ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç—å—é –∫ —Ü–µ–Ω—Ç—Ä—É
            const r = Math.pow(Math.random(), 1.5) * 25; // —Ä–∞–¥–∏—É—Å
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            
            positions[i*3] = x;
            positions[i*3+1] = y;
            positions[i*3+2] = z;
            
            // –¶–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–æ–ª–æ–∂–µ–Ω–∏—è
            const hue = (Math.atan2(y, x) / (Math.PI*2) + 0.5) % 1.0;
            const sat = 0.9;
            const light = 0.5 + (z / 25) * 0.3;
            color.setHSL(hue, sat, light);
            
            colors[i*3] = color.r;
            colors[i*3+1] = color.g;
            colors[i*3+2] = color.b;
            
            // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å (–º–∞–ª–µ–Ω—å–∫–∞—è)
            velocities.push({
                x: (Math.random() - 0.5) * 0.02,
                y: (Math.random() - 0.5) * 0.02,
                z: (Math.random() - 0.5) * 0.02
            });
        }

        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // –¢–µ–∫—Å—Ç—É—Ä–∞ —á–∞—Å—Ç–∏—Ü—ã (–∫—Ä—É–≥ —Å –º—è–≥–∫–∏–º –∫—Ä–∞–µ–º)
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(16, 16, 14, 0, 2 * Math.PI);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-atop';
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.beginPath();
        ctx.arc(16, 16, 10, 0, 2 * Math.PI);
        ctx.fill();
        
        const texture = new THREE.CanvasTexture(canvas);

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.25,
            map: texture,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            sizeAttenuation: true
        });

        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);

        // --- –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ô –≠–§–§–ï–ö–¢: –õ–£–ß–ò (AURA) ---
        const auraGeo = new THREE.SphereGeometry(8, 32, 16);
        const auraMat = new THREE.MeshBasicMaterial({
            color: 0x3366ff,
            transparent: true,
            opacity: 0.06,
            wireframe: true,
            side: THREE.BackSide
        });
        const aura = new THREE.Mesh(auraGeo, auraMat);
        scene.add(aura);

        // --- –ò–ù–¢–ï–†–ê–ö–¢–ò–í–ù–û–°–¢–¨ –ú–´–®–ò (3D –ü–û–ó–ò–¶–ò–Ø) ---
        const mouse = new THREE.Vector2();
        const mouse3D = new THREE.Vector3(0, 0, 0);
        const raycaster = new THREE.Raycaster();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // –ø–ª–æ—Å–∫–æ—Å—Ç—å Z=0 –¥–ª—è –ø—Ä–æ–µ–∫—Ü–∏–∏

        renderer.domElement.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            if (target) {
                mouse3D.copy(target);
                // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–¥–∏—É—Å –º—ã—à–∏
                if (mouse3D.length() > 30) {
                    mouse3D.normalize().multiplyScalar(30);
                }
            }
        });

        // --- –†–ï–ñ–ò–ú–´ –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–Ø ---
        let currentMode = 'attract'; // attract, repel, vortex, random
        const modeNames = {
            attract: '–ê–¢–¢–†–ê–ö–¢–û–†',
            repel: '–†–ï–ü–ï–õ–õ–ï–†',
            vortex: '–í–ò–•–†–¨',
            random: '–•–ê–û–°'
        };
        const modeElements = {
            attract: document.getElementById('mode-attract'),
            repel: document.getElementById('mode-repel'),
            vortex: document.getElementById('mode-vortex'),
            random: document.getElementById('mode-random')
        };

        Object.keys(modeElements).forEach(mode => {
            modeElements[mode].addEventListener('click', () => {
                currentMode = mode;
                document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
                modeElements[mode].classList.add('active');
                document.getElementById('current-mode').textContent = modeNames[mode];
            });
        });

        // --- –§–ò–ó–ò–ö–ê –ß–ê–°–¢–ò–¶ (–û–ë–ù–û–í–õ–ï–ù–ò–ï –ü–û–ó–ò–¶–ò–ô) ---
        const positionsAttr = particleSystem.geometry.attributes.position;
        const positionArray = positionsAttr.array;
        const count = particleCount;

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ (–Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –Ω–æ –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞)
        const originalPositions = positionArray.slice();

        function updateParticles() {
            // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–∏–ª—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞
            const mousePos = mouse3D;
            const strength = 0.5; // –æ–±—â–∞—è —Å–∏–ª–∞
            
            for (let i = 0; i < count; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;
                
                let px = positionArray[ix];
                let py = positionArray[iy];
                let pz = positionArray[iz];
                
                // –í–µ–∫—Ç–æ—Ä –æ—Ç —á–∞—Å—Ç–∏—Ü—ã –¥–æ –º—ã—à–∏
                const dx = mousePos.x - px;
                const dy = mousePos.y - py;
                const dz = mousePos.z - pz;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.1;
                
                // –°–∏–ª–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è (—á—Ç–æ–±—ã –¥–∞–ª–µ–∫–∏–µ —á–∞—Å—Ç–∏—Ü—ã –º–µ–Ω—å—à–µ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞–ª–∏)
                const influence = Math.max(0, 1 - dist / 20); // —Ä–∞–¥–∏—É—Å –≤–ª–∏—è–Ω–∏—è 20
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ä–µ–∂–∏–º
                if (currentMode === 'attract') {
                    // –ü—Ä–∏—Ç—è–∂–µ–Ω–∏–µ –∫ –º—ã—à–∏
                    if (dist < 20) {
                        const force = influence * strength * 0.05;
                        velocities[i].x += dx * force;
                        velocities[i].y += dy * force;
                        velocities[i].z += dz * force;
                    }
                } else if (currentMode === 'repel') {
                    // –û—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ –æ—Ç –º—ã—à–∏
                    if (dist < 15 && dist > 0.5) {
                        const force = influence * strength * 0.03;
                        velocities[i].x -= dx * force / dist;
                        velocities[i].y -= dy * force / dist;
                        velocities[i].z -= dz * force / dist;
                    }
                } else if (currentMode === 'vortex') {
                    // –í–∏—Ö—Ä—å –≤–æ–∫—Ä—É–≥ –º—ã—à–∏
                    if (dist < 15 && dist > 1) {
                        const force = influence * strength * 0.04;
                        // –ü–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω—ã–π –≤–µ–∫—Ç–æ—Ä (–æ—Å—å Y)
                        velocities[i].x += (dz * force) / dist;
                        velocities[i].z -= (dx * force) / dist;
                        // –ù–µ–±–æ–ª—å—à–æ–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
                        velocities[i].y += Math.sin(i) * 0.001;
                    }
                } else if (currentMode === 'random') {
                    // –•–∞–æ—Ç–∏—á–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ —Å –ø—Ä–∏—Ç—è–∂–µ–Ω–∏–µ–º –∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–º –ø–æ–∑–∏—Ü–∏—è–º
                    const origX = originalPositions[ix];
                    const origY = originalPositions[iy];
                    const origZ = originalPositions[iz];
                    
                    // –í–æ–∑–≤—Ä–∞—Ç –∫ –∏—Å—Ö–æ–¥–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
                    velocities[i].x += (origX - px) * 0.001;
                    velocities[i].y += (origY - py) * 0.001;
                    velocities[i].z += (origZ - pz) * 0.001;
                    
                    // –°–ª—É—á–∞–π–Ω—ã–µ —Ç–æ–ª—á–∫–∏
                    velocities[i].x += (Math.random() - 0.5) * 0.02;
                    velocities[i].y += (Math.random() - 0.5) * 0.02;
                    velocities[i].z += (Math.random() - 0.5) * 0.02;
                }
                
                // –ó–∞—Ç—É—Ö–∞–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
                velocities[i].x *= 0.99;
                velocities[i].y *= 0.99;
                velocities[i].z *= 0.99;
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
                positionArray[ix] += velocities[i].x;
                positionArray[iy] += velocities[i].y;
                positionArray[iz] += velocities[i].z;
                
                // –ú—è–≥–∫–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤ —Å—Ñ–µ—Ä–µ —Ä–∞–¥–∏—É—Å–∞ 35
                let x = positionArray[ix];
                let y = positionArray[iy];
                let z = positionArray[iz];
                const rad = Math.sqrt(x*x + y*y + z*z);
                if (rad > 35) {
                    const normX = x / rad;
                    const normY = y / rad;
                    const normZ = z / rad;
                    positionArray[ix] = normX * 34;
                    positionArray[iy] = normY * 34;
                    positionArray[iz] = normZ * 34;
                    velocities[i].x = 0;
                    velocities[i].y = 0;
                    velocities[i].z = 0;
                }
            }
            
            positionsAttr.needsUpdate = true;
        }

        // --- –ê–ù–ò–ú–ê–¶–ò–Ø –ò –í–†–ê–©–ï–ù–ò–ï –û–ë–™–ï–ö–¢–û–í ---
        let clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();
            const elapsedTime = performance.now() / 1000;

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∏–∑–∏–∫–∏ —á–∞—Å—Ç–∏—Ü
            updateParticles();

            // –í—Ä–∞—â–µ–Ω–∏–µ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
            torusKnot.rotation.x += 0.002;
            torusKnot.rotation.y += 0.005;
            
            sphere.rotation.x += 0.001;
            sphere.rotation.y += 0.003;
            
            cubes.forEach((cube, idx) => {
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.02;
                // –î–≤–∏–∂–µ–Ω–∏–µ –ø–æ –æ—Ä–±–∏—Ç–µ
                const angle = (idx / cubes.length) * Math.PI * 2 + elapsedTime * 0.2;
                cube.position.x = Math.cos(angle) * 6;
                cube.position.z = Math.sin(angle) * 6;
                cube.position.y = Math.sin(angle * 2) * 3;
            });

            // –ê—É—Ä–∞ –≤—Ä–∞—â–∞–µ—Ç—Å—è
            aura.rotation.y += 0.001;
            aura.rotation.x += 0.0005;

            // –ê–≤—Ç–æ–≤—Ä–∞—â–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            controls.update();

            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ —á–µ—Ä–µ–∑ –∫–æ–º–ø–æ–∑–µ—Ä
            composer.render();

            requestAnimationFrame(animate);
        }

        animate();

        // --- –û–ë–†–ê–ë–û–¢–ö–ê –†–ê–ó–ú–ï–†–ê –û–ö–ù–ê ---
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        }

        // --- –°–ß–ï–¢–ß–ò–ö –ß–ê–°–¢–ò–¶ (–ü–†–û–°–¢–û –î–õ–Ø –ö–†–ê–°–û–¢–´) ---
        document.getElementById('particle-count').textContent = particleCount;

        // --- –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ô –≠–§–§–ï–ö–¢: –ó–í–ï–ó–î–´ –ù–ê –§–û–ù–ï (–ß–ï–†–ï–ó –ß–ê–°–¢–ò–¶–´, –ù–û –ú–û–ñ–ù–û –ò –¢–ê–ö) ---
        // –£–∂–µ –µ—Å—Ç—å —á–∞—Å—Ç–∏—Ü—ã, –Ω–æ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Ñ–æ–Ω–æ–≤—ã–µ –∑–≤–µ–∑–¥—ã –æ—Ç–¥–µ–ª—å–Ω–æ
        const starGeo = new THREE.BufferGeometry();
        const starCount = 1000;
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            const r = 200 + Math.random() * 200;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            starPositions[i*3] = r * Math.sin(phi) * Math.cos(theta);
            starPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            starPositions[i*3+2] = r * Math.cos(phi);
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, map: texture, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        console.log('–°–∞–º—ã–π –°–ê–ú–´–ô –∫—Ä–∞—Å–∏–≤—ã–π –∏ —Å–ª–æ–∂–Ω—ã–π —Å–∞–π—Ç –∑–∞–ø—É—â–µ–Ω!');
    </script>
</body>
</html>
